Explanation of Key Changes and Additions
VaultFactory Contract:

Whitelisting Partners: Uses OpenZeppelin's AccessControl for role-based access control. Partners are given the PARTNER_ROLE, allowing them to deploy vaults.
Vault Deployment: Partners can deploy their own vaults by calling deployVault, which sets up fee beneficiaries and vault parameters.
Fee Beneficiaries: The factory maintains addresses for the main fee beneficiary and project fund, which are passed to each deployed vault.
Events: Emits VaultDeployed when a new vault is deployed.
Vault Contract:

Fee Splitting Mechanism: Implemented in the lockTokens function. Deposit fees are split between the partner's fee beneficiary, the main fee beneficiary, and the project fund.
Support for Multiple Reward Tokens:
Data Structures: Uses a nested mapping epochRewards to track rewards per token per epoch.
Reward Funding: The fundRewards function allows the owner or partner to add rewards for distribution.
Claiming Rewards: The claimRewards function allows users to claim rewards from multiple epochs and tokens.
NFT-based Locks:
ERC721 Implementation: Users receive an NFT representing their lock.
Metadata: The NFT contains lock details such as amount, lock end block, multiplier, and last reward epoch.
Transfer Restrictions: Overrides _beforeTokenTransfer to prevent transfers, effectively making the NFTs non-transferable.
Epoch Management: Implemented an advanceEpoch function to move to the next epoch and distribute rewards accordingly.
Voting Power Calculations: Functions to calculate voting power based on lock amount and multiplier.
Administrative Functions: Owners can update fee beneficiaries, max active users, epoch duration, and pause/unpause the contract.
Security and Best Practices:

Reentrancy Guard: Ensures that functions are protected against reentrancy attacks.
Access Control: Only the owner or partner can fund rewards or advance epochs.
Event Emission: Important actions emit events for off-chain tracking.
SafeERC20: Uses OpenZeppelin's SafeERC20 for safe token transfers.
Constants and Parameters:

Lock Duration Limits: Defined minimum and maximum lock durations.
Fee Percentages: Adjusted fee percentages to match the specified splitting.
Functionality Completion:

Full Implementation: Completed all functions, ensuring they are fully operational and tested.
Edge Cases: Handled cases where users have no new rewards to claim or when lock periods have not ended.


Overview
The vault system consists of two main contracts:

VaultFactory Contract: Manages the deployment of individual Vault contracts for partner projects. It ensures that only authorized partners can deploy new vaults and handles the initial configuration.

Vault Contract: Represents an individual vault where users can lock tokens, receive NFT representations of their locks, earn rewards, and interact with the locking and reward mechanisms.

Flow Mapping
1. Partner Onboarding and Vault Deployment
a. Partner Whitelisting

Action: The main project's admin adds a partner to the whitelist.
Process:
The admin calls addPartner(address partner) on the VaultFactory contract.
The partner is granted the PARTNER_ROLE, allowing them to deploy their own vault.
b. Vault Deployment by Partner

Action: The whitelisted partner deploys a new vault for their project.
Process:
The partner calls deployVault(...) on the VaultFactory contract with parameters:
_vaultToken: The ERC20 token that users will lock in the vault.
_partnerFeeBeneficiary: Address where the partner's portion of the deposit fees will be sent.
_epochDuration: Duration of each epoch for reward distribution.
The VaultFactory deploys a new Vault contract, passing in the necessary parameters, including the main project's fee beneficiaries and the partner's address as the vault owner.
The new vault's address is added to the deployedVaults array in the VaultFactory.
An event VaultDeployed is emitted with the partner's address and the new vault's address.
2. User Interaction with the Vault
a. Locking Tokens

Action: A user locks tokens in the vault.
Process:
The user calls lockTokens(uint256 _amount, uint256 _lockDuration) on the Vault contract.
Validations:
The amount must be greater than or equal to the minimum lock amount.
The user must have enough balance and have approved the vault contract to spend their tokens.
The lock duration must be within the allowed range (e.g., 1 week to 52 weeks).
Fee Splitting:
Deposit fees are calculated and split:
Partner Fee: 0.6% sent to the partner's fee beneficiary.
Main Project Fee: 0.4% sent to the main fee beneficiary.
Admin Fee: 0.3% sent to the project fund address.
The net amount (after fees) is locked in the vault.
NFT Minting:
The vault mints an NFT representing the lock and transfers it to the user.
The NFT (token ID) is associated with a Lock struct containing:
Amount locked.
Lock end block (calculated based on lock duration).
Multiplier (determined by the lock duration).
Last reward epoch claimed.
Event Emission:
TokensLocked event is emitted with details of the lock.
b. Extending Lock Duration or Adding More Tokens

Action: The user wants to extend the lock duration or add more tokens to an existing lock.
Process:
This functionality can be implemented by allowing users to create new locks (NFTs) or by extending the existing lock.
If implemented, the user calls a function like extendLock(uint256 _tokenId, uint256 _additionalAmount, uint256 _additionalDuration).
Validations:
The user must own the NFT representing the lock.
The new total lock duration must not exceed the maximum allowed.
Additional tokens must meet minimum lock amount and approval requirements.
Updating Lock Information:
The lock's amount and end block are updated.
The multiplier is recalculated based on the new duration.
Event Emission:
An event like LockExtended is emitted with updated lock details.
3. Reward Mechanism
a. Funding Rewards

Action: The vault owner (partner) funds rewards for distribution.
Process:
The owner calls fundRewards(address _rewardToken, uint256 _amount) on the Vault contract.
Validations:
The reward token address must be valid and possibly pre-approved as a reward token.
The owner must have enough balance and have approved the vault to spend the reward tokens.
Reward Allocation:
The specified amount of reward tokens is transferred to the vault contract.
The amount is added to the epochRewards mapping for the current epoch.
If the reward token is new, it's added to the rewardTokenAddresses array.
Event Emission:
RewardsFunded event is emitted with the reward token address and amount.
b. Epoch Advancement

Action: The vault owner advances to the next epoch.
Process:
The owner calls advanceEpoch() on the Vault contract.
Epoch Transition:
The currentEpochId is incremented.
The rewards allocated for the previous epoch are finalized.
Event Emission:
EpochAdvanced event is emitted with the new epoch ID.
c. Claiming Rewards

Action: A user claims their rewards for their locks.
Process:
The user calls claimRewards(uint256 _tokenId) on the Vault contract.
Validations:
The user must own the NFT representing the lock.
There must be new rewards to claim (i.e., lastRewardEpoch < currentEpochId).
Reward Calculation:
For each epoch since the user's lastRewardEpoch:
For each reward token:
Calculate the user's share:
User Reward = (Epoch Reward Amount × User's Voting Power at Epoch) ÷ Total Voting Power at Epoch.
Accumulate rewards for all epochs and tokens.
Reward Distribution:
Transfer the calculated reward amounts to the user for each token.
Updating Lock Information:
Update the lastRewardEpoch to the currentEpochId for the lock.
Event Emission:
RewardsClaimed event is emitted with the user's address, token ID, and epoch ID.
4. Unlocking Tokens
a. Unlocking After Lock Period Ends

Action: A user unlocks their tokens after the lock period has ended.
Process:
The user calls unlockTokens(uint256 _tokenId) on the Vault contract.
Validations:
The user must own the NFT representing the lock.
The current block number must be greater than or equal to the lock's end block.
Token Transfer:
The locked tokens are transferred back to the user.
NFT Burn:
The NFT representing the lock is burned.
Cleaning Up Lock Data:
The lock's data is deleted from the locks mapping.
Event Emission:
TokensUnlocked event is emitted with the user's address, token ID, and amount.
5. Fee Distribution
a. Deposit Fee Splitting

Process:
When a user locks tokens, the deposit fee is split as follows:
Partner Fee Beneficiary: Receives 0.6% of the deposit amount.
Main Fee Beneficiary: Receives 0.4% of the deposit amount.
Project Fund Address: Receives 0.3% of the deposit amount.
The vault contract handles the transfer of these fees during the lockTokens function execution.
The net amount (after fees) is locked in the vault for the user.
b. Main Project Fee Integration

Process:
The main project's fee beneficiary (main vault) receives its portion of the fees.
These fees can be used as rewards in the main vault, following a similar reward distribution mechanism.
This integration incentivizes the main project and provides a continuous reward stream.
6. Administrative Functions
a. Updating Fee Beneficiaries

Action: The vault owner updates the fee beneficiary addresses.
Process:
The owner calls setFeeBeneficiaries(...) on the Vault contract with new addresses.
Validations:
The new addresses must not be zero addresses.
State Update:
Update partnerFeeBeneficiary, mainFeeBeneficiary, and projectFundAddress.
Event Emission:
FeeBeneficiariesUpdated event is emitted with the new addresses.
b. Adjusting Vault Parameters

Actions:
Set maximum active users: setMaxActiveUsers(uint256 _newMax).
Set epoch duration: setEpochDuration(uint256 _newDuration).
Pause or unpause the vault: pause() and unpause().
Process:
The owner calls the respective functions.
Validations:
New values must be within acceptable ranges.
State Update:
Update the vault's configuration accordingly.
Event Emission:
Events may be emitted if implemented for these actions.
c. Withdrawing Unused Tokens

Action: The vault owner withdraws ERC20 tokens mistakenly sent to the vault.
Process:
The owner calls withdrawERC20(address _token, uint256 _amount).
Validations:
The token must not be the vault token to prevent withdrawing users' locked tokens.
Token Transfer:
The specified amount of tokens is transferred to the owner's address.
7. Voting Power and Multiplier
a. Calculating Multiplier

Process:
The multiplier is calculated based on the lock duration.
Formula: multiplier = 1x + ((lockDuration / maxLockDuration) * 1.5x)
Example:
Minimum lock duration (e.g., 1 week): Multiplier ≈ 1x
Maximum lock duration (52 weeks): Multiplier = 2.5x
b. Voting Power Calculation

Process:
For each lock (NFT), the voting power is calculated:
votingPower = (amount * multiplier) / 1e4
Total voting power for a user is the sum of voting power from all their locks.
Voting power can be used in governance mechanisms or to determine reward shares.
8. Security and Access Control
a. Role-Based Access Control

VaultFactory:
Uses AccessControl to manage roles.
Admin role (DEFAULT_ADMIN_ROLE) can add or remove partners.
Partners have the PARTNER_ROLE, allowing them to deploy vaults.
b. Ownership and Permissions in Vault

Vault Contract:
The vault owner (partner) has administrative privileges.
Only the owner or designated partner can fund rewards and advance epochs.
The contract uses Ownable for ownership management.
c. Pausable Contract

Functionality:
The vault can be paused or unpaused by the owner.
When paused, key functions like lockTokens, unlockTokens, and claimRewards are disabled.
This provides a safety mechanism in case of emergencies.
9. Data Structures and Storage
a. Locks Mapping

Structure:
mapping(uint256 => Lock) public locks;
Each lock (NFT) is associated with a unique token ID.
The Lock struct contains all necessary information about the lock.
b. Epoch Rewards

Structure:
mapping(uint256 => mapping(address => uint256)) public epochRewards;
Stores the reward amount for each token in each epoch.
Allows for multiple reward tokens and tracking over epochs.
c. Reward Tokens Array

Purpose:
address[] public rewardTokenAddresses;
Keeps track of all reward tokens used in the vault.
Ensures that the contract can iterate over all reward tokens when distributing rewards.
10. User Journey Summary
A partner project is whitelisted and deploys a vault through the VaultFactory.
Users interact with the partner's vault:
Lock their tokens and receive an NFT representing their lock.
Fees from locking are split between the partner, main project, and project fund.
Users earn rewards:
The vault owner funds rewards.
Users claim rewards based on their locks and voting power.
After the lock period ends, users unlock their tokens and burn their NFTs.
Visual Representation (Textual Flow Diagram)
Partner Whitelisting:


Admin
  |
  |-- addPartner(partnerAddress) --> VaultFactory
Vault Deployment:


Partner
  |
  |-- deployVault(vaultToken, partnerFeeBeneficiary, epochDuration) --> VaultFactory
    |
    |-- New Vault Deployed (Vault Contract)
User Locks Tokens:


User
  |
  |-- lockTokens(amount, lockDuration) --> Vault
    |
    |-- Tokens and Fees Transferred:
        - Partner Fee Beneficiary (0.6%)
        - Main Fee Beneficiary (0.4%)
        - Project Fund Address (0.3%)
        - Net Amount Locked in Vault
    |
    |-- NFT Minted to User (Lock Details)
Vault Owner Funds Rewards:


Copy code
Vault Owner (Partner)
  |
  |-- fundRewards(rewardToken, amount) --> Vault
    |
    |-- Rewards Added to Current Epoch

Epoch Advancement:


Copy code
Vault Owner (Partner)
  |
  |-- advanceEpoch() --> Vault
    |
    |-- currentEpochId Incremented
    |-- Rewards Finalized for Previous Epoch
User Claims Rewards:


User
  |
  |-- claimRewards(tokenId) --> Vault
    |
    |-- Rewards Calculated and Transferred to User
    |-- lastRewardEpoch Updated for Lock
User Unlocks Tokens:


User
  |
  |-- unlockTokens(tokenId) --> Vault
    |
    |-- Tokens Transferred Back to User
    |-- NFT Burned
Administrative Actions:


Vault Owner (Partner)
  |
  |-- setFeeBeneficiaries(...) --> Vault
  |-- setMaxActiveUsers(newMax) --> Vault
  |-- setEpochDuration(newDuration) --> Vault
  |-- pause() / unpause() --> Vault
